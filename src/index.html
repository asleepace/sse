<!doctype html>
<html>

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
</head>

<body
  class="min-h-screen overflow-x-hidden overscroll-x-none w-full bg-black text-green-500 font-mono flex flex-1 flex-col">
  <div id="messages" class="flex-1 flex flex-col gap-1 p-8"></div>

  <script>
    async function createEventStream() {
      const path = new URL('/sse', window.location.origin)
      const resp = await fetch(path, { method: 'OPTIONS' })
      if (!resp.ok) throw new Error(`${resp.status}: ${resp.statusText}`)
      const json = await resp.json()
      if (!json.streamId) throw new Error('Missing stream ID!')
      path.searchParams.set('streamId', json.streamId)
      return path
    }


    const insertMessage = (data) => {
      const output = document.getElementById('messages');
      const elem = document.createElement('div');
      elem.textContent = typeof data === 'string' ? data : JSON.stringify(data);
      output?.appendChild(elem);
    };

    // create a new event source

    async function useEventSource(onEventCallback) {
      const stream = Promise.withResolvers();
      const apiUrl = await createEventStream()
      insertMessage("requested stream on " + apiUrl)
      const source = new EventSource(apiUrl);
      const state = new Proxy({
        isConnected: false,
        streamId: undefined,
        messages: [],
        taskIds: [],
        updatedAt: new Date(),
        createdAt: new Date(),
      }, {
        set(target, propKey, newValue, recv) {
          if (propKey === 'updatedAt') return true
          target.updatedAt = new Date()
          return Reflect.set(target, propKey, newValue, recv)
        }
      })
      source.onopen = (ev) => {
        state.isConnected = true;
        stream.resolve();
        onEventCallback?.({ type: 'open', data: ev.data });
      };
      source.onerror = (ev) => {
        state.isConnected = false;
        onEventCallback?.({ type: 'error', data: ev.data });
      };
      source.onmessage = (ev) => {
        state.messages.push(ev.data);
        onEventCallback?.({ type: 'message', data: ev.data });
      };
      source.addEventListener('keep-alive', (ev) => {
        onEventCallback?.({ type: 'ping', data: ev.data });
      });
      return {
        isReady() {
          return stream.promise;
        },
        get state() {
          return state;
        },
        async fetchStream(data) {
          const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-Stream-ID': state.streamId,
            },
            body: JSON.stringify(data)
          });
          console.log("[fetchTask] resp:", response.status, response.statusText);
          const taskId = response.headers.get('X-Task-ID');
          if (taskId) {
            state.taskIds.push(taskId);
          }
        }
      };
    }


    function isMaybeJSON(obj) {
      if (!obj || typeof obj !== "string") return false
      if (obj.length === 0) return false
      const firstChar = obj.charAt(0)
      if (firstChar === '[' || firstChar === '{') {
        return true
      } else {
        console.log('[isMaybeJSON] char:', firstChar, obj)
        return false
      }
    }

    function safeDecodeJSON(obj) {
      try {
        if (!isMaybeJSON(obj)) throw new Error('No valid JSON!')
        return JSON.parse(obj.trim())
      } catch (e) {
        return String(obj)
      }
    }


    function parseClientMessage(message) {
      try {

        if (typeof message !== 'string') {
          throw new Error('Unknown type:' + message)
        }

        const hasNewlines = message.includes('\n')

        if (hasNewlines) {
          const components = message.split('\n')
          const strs = components.map(safeDecodeJSON)
          return strs.join(", ")
        } else {
          return safeDecodeJSON(message.trim())
        }
      } catch (e) {
        return String(message)
      }
    }


    // implementation 

    useEventSource((ev) => {
      switch (ev.type) {
        case 'open':
          insertMessage("client connected ğŸŸ¢")
          break
        case 'error':
          insertMessage("client error ğŸ”´")
          break
        case 'ping':
          insertMessage("client ping ğŸ’“")
          break
        case 'message':
          const msg = parseClientMessage(ev.data)
          console.log("[client:message] data:", msg)
          insertMessage(ev.data)
          break
        default:
          insertMessage("client unknown ğŸ¤”")
          break
      }
    })

    
  </script>
</body>
</html>